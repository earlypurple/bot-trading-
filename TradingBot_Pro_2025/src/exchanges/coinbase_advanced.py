#!/usr/bin/env python3
"""
üöÄ Coinbase Advanced Trade API Connector - TradingBot Pro 2025
===============================================================
Connecteur authentifi√© pour l'API Coinbase Advanced Trade
Permet d'acc√©der au portfolio, de passer des ordres, etc.

üìö Documentation: https://docs.cloud.coinbase.com/advanced-trade-api/docs/
üîê Authentification: API Key + Secret (Cloud Trading)
"""

import requests
import json
import time
import hmac
import hashlib
import base64
import logging
from typing import Dict, List, Optional, Any
from datetime import datetime
import uuid

# Configuration du logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class CoinbaseAdvancedConnector:
    """Connecteur pour l'API Coinbase Advanced Trade avec authentification"""
    
    def __init__(self, api_key: str, api_secret: str, sandbox: bool = True):
        """
        Initialise le connecteur Coinbase Advanced Trade
        
        Args:
            api_key: Cl√© API Coinbase
            api_secret: Secret API Coinbase  
            sandbox: True pour sandbox, False pour production
        """
        self.api_key = api_key
        self.api_secret = api_secret
        self.sandbox = sandbox
        
        # URLs de base
        if sandbox:
            self.base_url = "https://api.coinbase.com"  # Pas de sandbox pour Advanced Trade
            logger.warning("‚ö†Ô∏è Advanced Trade API n'a pas de sandbox, utilisation de la production")
        else:
            self.base_url = "https://api.coinbase.com"
            
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'TradingBot-Pro-2025/1.0',
            'Accept': 'application/json',
            'Content-Type': 'application/json'
        })
        
    def _generate_signature(self, timestamp: str, method: str, path: str, body: str = "") -> str:
        """G√©n√®re la signature HMAC pour l'authentification"""
        message = f"{timestamp}{method}{path}{body}"
        signature = hmac.new(
            self.api_secret.encode('utf-8'),
            message.encode('utf-8'),
            hashlib.sha256
        ).hexdigest()
        return signature
    
    def _make_request(self, method: str, endpoint: str, params: Dict = None, data: Dict = None) -> Dict[str, Any]:
        """Effectue une requ√™te authentifi√©e vers l'API"""
        try:
            timestamp = str(int(time.time()))
            path = f"/api/v3/{endpoint.lstrip('/')}"
            url = f"{self.base_url}{path}"
            
            # Pr√©paration du body
            body = ""
            if data:
                body = json.dumps(data)
            
            # G√©n√©ration de la signature
            signature = self._generate_signature(timestamp, method.upper(), path, body)
            
            # Headers d'authentification
            headers = {
                'CB-ACCESS-KEY': self.api_key,
                'CB-ACCESS-SIGN': signature,
                'CB-ACCESS-TIMESTAMP': timestamp,
            }
            
            # Mise √† jour des headers
            self.session.headers.update(headers)
            
            # Requ√™te
            if method.upper() == 'GET':
                response = self.session.get(url, params=params, timeout=10)
            elif method.upper() == 'POST':
                response = self.session.post(url, json=data, timeout=10)
            else:
                raise ValueError(f"M√©thode HTTP non support√©e: {method}")
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.RequestException as e:
            logger.error(f"‚ùå Erreur requ√™te API: {e}")
            if hasattr(e, 'response') and e.response is not None:
                try:
                    error_detail = e.response.json()
                    logger.error(f"D√©tail erreur: {error_detail}")
                except:
                    logger.error(f"Statut HTTP: {e.response.status_code}")
            return {}
        except Exception as e:
            logger.error(f"‚ùå Erreur g√©n√©rale: {e}")
            return {}
    
    def get_accounts(self) -> List[Dict[str, Any]]:
        """R√©cup√®re les comptes/portefeuilles"""
        try:
            response = self._make_request('GET', 'brokerage/accounts')
            if 'accounts' in response:
                logger.info(f"‚úÖ {len(response['accounts'])} comptes r√©cup√©r√©s")
                return response['accounts']
            else:
                logger.warning("‚ö†Ô∏è Aucun compte trouv√©")
                return []
                
        except Exception as e:
            logger.error(f"‚ùå Erreur r√©cup√©ration comptes: {e}")
            return []
    
    def get_account_balance(self, account_id: str) -> Dict[str, Any]:
        """R√©cup√®re le solde d'un compte sp√©cifique"""
        try:
            response = self._make_request('GET', f'brokerage/accounts/{account_id}')
            if 'account' in response:
                account = response['account']
                logger.info(f"‚úÖ Solde {account.get('currency', 'N/A')}: {account.get('available_balance', {}).get('value', '0')}")
                return account
            else:
                logger.warning(f"‚ö†Ô∏è Compte {account_id} non trouv√©")
                return {}
                
        except Exception as e:
            logger.error(f"‚ùå Erreur solde compte {account_id}: {e}")
            return {}
    
    def get_products(self) -> List[Dict[str, Any]]:
        """R√©cup√®re la liste des produits/paires de trading"""
        try:
            response = self._make_request('GET', 'brokerage/products')
            if 'products' in response:
                logger.info(f"‚úÖ {len(response['products'])} produits disponibles")
                return response['products']
            else:
                logger.warning("‚ö†Ô∏è Aucun produit trouv√©")
                return []
                
        except Exception as e:
            logger.error(f"‚ùå Erreur r√©cup√©ration produits: {e}")
            return []
    
    def get_product_candles(self, product_id: str, start: str, end: str, granularity: str = "ONE_HOUR") -> List[Dict[str, Any]]:
        """R√©cup√®re les donn√©es de chandelier pour un produit"""
        try:
            params = {
                'start': start,
                'end': end,
                'granularity': granularity
            }
            response = self._make_request('GET', f'brokerage/products/{product_id}/candles', params=params)
            
            if 'candles' in response:
                logger.info(f"‚úÖ {len(response['candles'])} bougies r√©cup√©r√©es pour {product_id}")
                return response['candles']
            else:
                logger.warning(f"‚ö†Ô∏è Aucune bougie trouv√©e pour {product_id}")
                return []
                
        except Exception as e:
            logger.error(f"‚ùå Erreur candles {product_id}: {e}")
            return []
    
    def place_order(self, product_id: str, side: str, size: str, price: str = None, order_type: str = "market") -> Dict[str, Any]:
        """Place un ordre de trading"""
        try:
            order_data = {
                "client_order_id": str(uuid.uuid4()),
                "product_id": product_id,
                "side": side.lower(),  # "buy" ou "sell"
                "order_configuration": {}
            }
            
            if order_type.lower() == "market":
                if side.lower() == "buy":
                    order_data["order_configuration"] = {
                        "market_market_ioc": {
                            "quote_size": size  # Montant en devise de quote
                        }
                    }
                else:
                    order_data["order_configuration"] = {
                        "market_market_ioc": {
                            "base_size": size  # Quantit√© en devise de base
                        }
                    }
            elif order_type.lower() == "limit":
                order_data["order_configuration"] = {
                    "limit_limit_gtc": {
                        "base_size": size,
                        "limit_price": price
                    }
                }
            
            response = self._make_request('POST', 'brokerage/orders', data=order_data)
            
            if 'success' in response and response['success']:
                logger.info(f"‚úÖ Ordre plac√©: {response.get('order_id', 'ID inconnu')}")
                return response
            else:
                logger.error(f"‚ùå √âchec placement ordre: {response}")
                return {}
                
        except Exception as e:
            logger.error(f"‚ùå Erreur placement ordre: {e}")
            return {}
    
    def get_orders(self, product_id: str = None, order_status: str = None) -> List[Dict[str, Any]]:
        """R√©cup√®re les ordres"""
        try:
            params = {}
            if product_id:
                params['product_id'] = product_id
            if order_status:
                params['order_status'] = order_status
                
            response = self._make_request('GET', 'brokerage/orders/historical/batch', params=params)
            
            if 'orders' in response:
                logger.info(f"‚úÖ {len(response['orders'])} ordres r√©cup√©r√©s")
                return response['orders']
            else:
                logger.warning("‚ö†Ô∏è Aucun ordre trouv√©")
                return []
                
        except Exception as e:
            logger.error(f"‚ùå Erreur r√©cup√©ration ordres: {e}")
            return []
    
    def get_portfolio_summary(self) -> Dict[str, Any]:
        """R√©cup√®re un r√©sum√© du portfolio"""
        try:
            accounts = self.get_accounts()
            if not accounts:
                return {}
            
            portfolio = {
                'total_value_usd': 0,
                'balances': {},
                'account_count': len(accounts)
            }
            
            for account in accounts:
                currency = account.get('currency', 'UNKNOWN')
                available = float(account.get('available_balance', {}).get('value', '0'))
                hold = float(account.get('hold', {}).get('value', '0'))
                total = available + hold
                
                if total > 0:
                    portfolio['balances'][currency] = {
                        'available': available,
                        'hold': hold,
                        'total': total
                    }
            
            logger.info(f"‚úÖ Portfolio: {len(portfolio['balances'])} devises avec solde")
            return portfolio
            
        except Exception as e:
            logger.error(f"‚ùå Erreur r√©sum√© portfolio: {e}")
            return {}
    
    def test_connection(self) -> Dict[str, Any]:
        """Test la connexion √† l'API"""
        try:
            accounts = self.get_accounts()
            if accounts:
                return {
                    'status': 'success',
                    'message': f'Connexion r√©ussie - {len(accounts)} comptes trouv√©s',
                    'authenticated': True
                }
            else:
                return {
                    'status': 'error', 
                    'message': 'Connexion √©chou√©e - Aucun compte trouv√©',
                    'authenticated': False
                }
                
        except Exception as e:
            return {
                'status': 'error',
                'message': f'Erreur de connexion: {e}',
                'authenticated': False
            }

def test_connector():
    """Test du connecteur avec des cl√©s d'exemple"""
    print("üöÄ Test Coinbase Advanced Trade Connector")
    print("=" * 60)
    
    # ATTENTION: Il faut remplacer par tes vraies cl√©s API
    api_key = "your_api_key_here"
    api_secret = "your_api_secret_here"
    
    if api_key == "your_api_key_here":
        print("‚ùå Veuillez configurer vos vraies cl√©s API Coinbase")
        print("üîó Cr√©ez vos cl√©s sur: https://cloud.coinbase.com/access/api")
        print("\nüìã Permissions requises:")
        print("  - wallet:accounts:read")
        print("  - wallet:trades:read") 
        print("  - wallet:orders:read")
        print("  - wallet:orders:create (pour le trading)")
        return
    
    # Test du connecteur
    connector = CoinbaseAdvancedConnector(api_key, api_secret)
    
    # Test de connexion
    print("\nüì° Test de connexion...")
    result = connector.test_connection()
    print(f"Status: {result['status']}")
    print(f"Message: {result['message']}")
    
    if result['status'] == 'success':
        print("\nüí∞ R√©sum√© du portfolio...")
        portfolio = connector.get_portfolio_summary()
        if portfolio:
            print(f"Nombre de comptes: {portfolio.get('account_count', 0)}")
            for currency, balance in portfolio.get('balances', {}).items():
                print(f"  {currency}: {balance['total']:.8f} (disponible: {balance['available']:.8f})")
        
        print("\nüìä Produits disponibles (top 5)...")
        products = connector.get_products()
        for product in products[:5]:
            print(f"  {product.get('product_id', 'N/A')} - Status: {product.get('status', 'N/A')}")

if __name__ == "__main__":
    test_connector()
